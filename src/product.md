# product

## me

非常荣幸能有机会向您介绍自己。我是一名具有三年工作经验的Java开发工程师，毕业于计算机科学专业。

1. 在过去的三年中，专注于Java开发，参与了多个项目的开发和实施。我熟悉Java语言的基础知识和核心特性，包括面向对象编程、异常处理、多线程等。同时，我也熟练掌握了SpringBoot，Mybatis等主流Java开发框架，具备丰富的Web应用开发经验。

2. 除了Java开发，我也具备扎实的数据结构和算法基础，能够熟练地处理数据库操作和优化。我熟悉MySQL等主流关系型数据库，并具备良好的SQL编程能力。

3. 在工作中，我始终注重团队合作和沟通。我能够与同事紧密合作，共同解决项目中的各种技术难题。同时，我也非常注重代码的可读性和可维护性。

4. 除了技术能力以外，我也非常注重自身的学习和成长。我经常阅读技术博客和书籍，关注最新的技术动态和发展趋势。希望能够不断提升自己的技术水平和综合素质。
   在前公司做java工程师，主要的任务是：与项目经理到客户现场沟通并确认需求，并参与需求文档的编写。在设计阶段，参与详细设计，包括框架的一些基类、工具类的封装，使用powerdesigner完成数据库的设计。对数据库设计有一定的经验，常用的数据库包括mysql、oracle等关系型数据库，还有mongodb、redis等非关系型数据库，并在linux上搭建集群和哨兵和部署项目。编码过程中，主要负责一些功能模块的编码实现，并使用junit做单元测试。项目管理上，与项目经理沟通协调过项目的进度，使用maven对项目进行管理，还帮助其他开发人员解决一些开发过程中的问题。
   总之，我相信我的技能和经验能够为贵团队带来更多的价值，并期待有机会成为贵团队的一员。谢谢！
   
   ## introduce

5. 首先，这个项目的目标是为新媒体运营用户提供流畅、稳定、高效的播控服务，从而体现为我们在TV当中看到的一些付费内容。为了实现这一目标，我们选择了微服务架构，这样可以更好地满足高并发、可伸缩和易扩展的需求。

6. 在技术栈方面，我们主要使用了基于 SpringCloud Alibaba 系列微服务组件进行落地实现，使用RabbitMq 进行异步消息通信和XXl-job拉取的策略进行削峰处理

7. 在开发和部署流程中，我们采用了敏捷开发方法，并使用Jenkins GitLab 进行自动化测试和部署。

8. 监控和日志我们使用了使用ELK stack进行日志管理，可以快速地发现问题并进行故障排除。
   总的来说，这个项目让我学到了很多关于微服务架构的知识和经验。通过这个项目，我了解了如何设计一个高效、可扩展、易维护的系统，并且学会了如何使用各种工具和技术来优化性能、提高可用性、确保安全性等。我相信这些经验和技能将对我的未来工作产生积极的影响。
   感谢您给我这个机会来介绍我的项目！如果您有任何问题或者需要进一步讨论，请随时告诉我。

9. 我的主要工作是负责下发服务的开发，需要对接编排组和使用Webservice对接下游，包括需求分析、代码开发、接口设计、性能优化和容错措施等

## 难点 亮点

1. 缓存优化：为了提高视频播放的流畅性和效率，我使用了多级缓存机制。在服务器端，我使用了Redis等内存数据库来存储视频数据，并通过合理的缓存策略来提高数据访问速度。在客户端，我使用了浏览器缓存和离线缓存技术，使得用户可以在不同设备上继续观看视频，提高了用户体验。
2. 容错与错误恢复：为了保证视频播放的稳定性和可靠性，我实现了容错与错误恢复机制。当视频播放过程中出现错误时，我可以自动切换到备用视频流或重新请求视频数据，从而保证用户可以继续观看视频而不受干扰。
3. 并发多线程： 提高性能，使用多线程技术，可以同时发布多个工单
4. 异常排查：线程隔离
5. 采取策略模式对接编排组，模版设计模式进行下发
   
   ## RabbitMQ
   
   （1）服务间**异步通信**
   （2）顺序消费
   （3）定时任务
   （4）请求**削峰**
   (5) 服务**解耦**
   RabbitMQ是**伪分布式**的，只能部署镜像集群，集群中国内每台集群存储的数据是一样的，只能*垂直扩展*，没能水平扩展。 
   而Kafka和RocketMQ都是将message拆分后存储到不同的partition上，然后每个partition对应一个主节点，其他机器存储副本。

## 可靠性

①消息的传输：通过协议来保证系统间数据解析的正确性。

②消息的存储可靠：通过持久化来保证消息的可靠性。

> RabbitMQ集群是**伪分布式**。普通集群模式（不能高可用）的缺点是在rabbitmq集群内部存在大量数据传输，可用性没有保障，存有数据的机器宕机，数据丢失。而镜像集群模式虽然解决了高可用的问题，但它仍然不是分布式的，数据量太大会存在问题。

## XXL-job

采取XXL-JOB定时拉取消息的策略，主要是出于以下几个方面的考虑：

1. 减少对消息队列的**频繁操作**：在XXL-JOB中，我们可以通过配置定时任务的时间间隔，来控制拉取消息的频率。通过减少对消息队列的频繁操作，可以降低系统的负载和网络流量，提高系统的稳定性和性能。
2. 实现任务的**异步处理**：定时拉取消息的策略可以实现任务的异步处理。当系统接收到一个任务时，它可以将任务放入消息队列中，然后由XXL-JOB定时拉取消息并处理。这种异步处理方式可以避免阻塞主线程，提高系统的响应速度和并发处理能力。
3. 提高系统的**可扩展性**：XXL-JOB定时拉取消息的策略可以与多个系统进行**集成**，实现任务的分布式处理。通过将任务分散到不同的节点上进行处理，可以提高系统的可扩展性和处理能力，满足大规模数据处理的需求。
4. 降低对消息队列的**压力**：频繁地向消息队列发送和接收消息可能会对消息队列造成较大的压力。而通过XXL-JOB定时拉取消息的策略，可以控制消息的流量，避免对消息队列造成过大的压力，提高系统的可靠性和稳定性。
   总之，采取XXL-JOB定时拉取消息的策略主要是为了减少对消息队列的频繁操作、实现任务的异步处理、提高系统的可扩展性以及降低对消息队列的压力。这种策略可以帮助我们更好地管理任务和处理消息，提高系统的性能和可靠性。

## Redis

### data type

好的，我会继续说明我在这个项目中使用的Redis数据类型及其解决的问题。

1. 在这个项目中，我还使用了Redis的列表类型（List）来解决一些问题。具体来说，我使用Redis列表来存储视频播放的历史记录。

当用户观看视频时，我可以将视频的ID添加到用户的播放历史记录列表中。这样，我可以方便地获取用户的历史播放记录，并用于推荐相似的视频或者提供回顾功能。

2. 另外，我还使用Redis的集合类型（Set）来存储和管理视频的标签信息。通过将视频的标签存储在Redis集合中，我可以快速地获取和更新视频的标签信息，并用于搜索和过滤视频。

3. 此外，我还使用了Redis的有序集合类型（Sorted Set）来存储和管理视频的评分信息。通过将每个视频的评分和评分人数存储在有序集合中，我可以根据评分排序视频列表，并用于推荐高质量的视频给用户。

4. 

5. 使用Redis的哈希表类型来存储用户的会话信息是因为会话信息包含了多个键值对，而且需要在一个事务中保持一致性。通过使用哈希表，我可以方便地获取和更新用户的会话状态，并保持会话的持续性。

## 集群

Redis 支持三种集群方案
一个是读写分离，分担 "master" 的读写压力
一个是方便做容灾恢复

### 主从复制模式

1. Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复（也就是要人工介入）；
2. 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；
3. 如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送sync 请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO 剧增从而宕机。
4. Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂

### Sentinel（哨兵）模式

哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个 Redis 实例。

### Cluster 模式

Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂
总结：引入主从复制机制的目的有两个

1. 数据自动切分：可以将数据分散到多个节点上，提高了数据的处理能力和可靠性。
2. 高可用性：支持多个主节点和从节点，当主节点出现故障时，可以自动切换到从节点继续处理命令请求。
3. 读写分离：主节点负责写入操作，从节点负责读取操作，提高了系统的吞吐量和性能。
4. 分布式存储：使用分布式存储技术，可以将数据分散到多个节点上，提高了数据的可靠性和可用性。
5. 自动容错：可以自动检测节点的故障，并且可以将故障节点从集群中移除，保证了集群的正常运行。

## Nacos

### 配置中心

首先，Nacos采用的是长轮询的方式。也就是说，由Nacos Client向Nacos Server端去发起配置更新查询的请求。所谓长轮询，就是客户端发起一次轮询请求到服务器端，当服务器端的配置没有任何变更的时候，这个连接会一直打开，直到服务端有配置变更或者连接超时之后才返回
Nacos的配置中心的实现方式有两种：

- 基于数据库的配置中心
- 基于内存的配置中心

基于数据库的配置中心的实现方式是将配置信息存储在数据库中，而基于内存的配置中心的实现方式是将配置信息存储在内存中。

基于数据库的配置中心的优势在于：

- 实现了配置的集中管理，方便统一管理和维护

基于内存的配置中心的优势在于：

- 实现了配置的快速响应，提高了系统的响应速度
- 实现了配置的动态更新，可以实时更新配置信息

基于内存的配置中心的劣势在于：

- 实现了配置的集中管理，方便统一管理和维护
- 实现了配置的动态更新，可以实时更新配置信息

基于内存的配置中心的适用场景：

- 系统中需要实时获取配置信息，并且配置信息较少，可以考虑使用基于内存的配置中心
- 系统中需要对配置信息进行集中管理，并且配置信息较少，可以考虑使用基于内存的配置中心
- 系统中需要对配置信息进行动态更新，并且配置信息较少，可以考虑使用基于内存的配置中心

配置中心一般都会配置什么内容？(可能会经常变化的配置信息，例如连接池，日志，线程池，限流熔断规则)
什么信息一般不会写到配置中心？(服务端口，服务名，服务的注册地址，配置中心)
项目中为什么要定义bootstrap.yml文件？(此文件被读取的优先级比较高，可以在服务启动时读取配置中心的数据)
Nacos配置中心宕机了，我们的服务还可以读取到配置信息吗?(可以从内存，客户端获取配置中心的配置信息以后，会将配置信息在本地存储一份)
微服务应用中我们的客户端如何从配置中心获取信息？(我们的服务一般会**先从内存**中读取配置信息，同时我们的微服务还可以定时向nacos配置中心发请求拉取(pull)更新的配置信息)
微服务应用中客户端如何感知配置中心的数据变化？(1.4.x版本以后nacos客户端会基于**长轮询机制**从nacos获取配置信息，所谓的长轮询就是没有配置更新时，会在nacos服务端的队列进行等待)
服务启动后没有从配置中心获取我们的配置数据是什么原因？(依赖，配置文件名字bootstrap.yml，配置中心的DataId名字是否正确，缩进关系是否正确，假如是动态发布，类上是否有**RefreshScope**注解)
你项目中使用的日志规范是什么？(SLF4J)
你了解项目中的日志级别吗？(debug,info,error,可以基于日志级别控制日志的输出)
Nacos配置管理模型背景?（环境不同，配置不同）
Nacos配置中的管理模型是怎样的？(namespace，group，service/data-id)
Nacos客户端是否可以读取共享配置？(可以)

## 负载均衡

负载均衡是指将用户的请求分配到多个服务器上，以达到提高系统吞吐量和减少服务器的压力的一种策略。常见的负载均衡有：

- DNS负载均衡：DNS服务器可以将用户的请求分配到多个服务器上，从而达到负载均衡的目的。
- 硬件负载均衡：
- 软件负载均衡：软件负载均衡可以将用户的请求分配到多个服务器上，从而达到负载均衡的目的。
  -- Nginx：Nginx是一款高性能的HTTP和反向代理服务器，同时也提供了IMAP/POP3/SMTP服务。
  -- Apache：Apache是一款开源的Web服务器，Apache HTTP Server是Apache软件的一个组件，提供HTTP和HTTPS两种协议服务。
  -- HAProxy：HAProxy是一款免费、高性能、开源的TCP/HTTP代理服务器，可提供负载均衡、故障转
  -- Nacos：Nacos是一款基于Java开发的动态服务发现、配置管理和服务管理平台，致力于帮助您发现、配置和管理微服务。
  -- Consul：Consul是一款开源工具，用于服务发现和配置，支持多数据中心部署。
  -- Eureka：Eureka是Netflix公司开源的服务注册与发现工具，主要用于中间层服务，提供基于REST的服务注册与发现机制

@LoadBalanced的作用是什么？我们可以自己定义负载均衡策略吗？(可以，基于IRule接口进行策略定义，也可以参考NacosRule进行实现)

 Nacos 注册中心中，内置了两种负载均衡策略：**基于权重**和基于 **CMDB（低于就近访问）**的负载均衡策略。

我们可以自己定义负载均衡策略吗？(可以，基于IRule接口进行策略定义，也可以参考NacosRule进行实现)

### Feign

为什么使用feign？(基于Feign可以更加友好的实现**服务调用**，简化服务消费方对服务提供方方法的调用)
FeignClient注解的作用是什么？(告诉Feign Starte，在项目启动时，为此注解描述的接口创建实现类-代理类)
Feign方式的调用，，底层负载均衡是如何实现的？(Ribbon）
EnableFeignClients注解的作用是什么？(描述配置类，例如启 动类)

## Mysql

### SQL 优化

1. 使用索引：为经常用于查询的列创建索引，建立组合索引，覆盖索引，避免回表扫描
2. 优化查询语句：明确指定需要的字段，避免子查询
3. 分页查询：如果需要查询大量数据，可以使用分页查询来限制返回的结果集大小，减少一次查询的数据量。
4. 优化数据库架构：合理设计数据库架构，减少表的关联关系，减少冗余数据等。
5. 使用缓存：将经常查询的数据缓存到内存中，减少磁盘I/O操作
6. 升级硬件资源：如果数据库服务器硬件资源不足，可以考虑升级硬件设备，提高性能。
7. 使用索引优化工具：MySQL提供了一些索引优化工具，如EXPLAIN语句和OPTIMIZE TABLE语句等，可以帮助分析查询性能瓶颈并进行优化。

# 事故

## 1、接口超时事故

##### 1）、现象

  2021年12月某周一上午，负责管理网络的同事(俗称网管)一大早巡检过程中发现有一个服务挂掉了，他当时没在意，直接重启就好了，但到了10点左右，忽然三四个服务：挂号服务、门诊服务、检查报告服务等一起挂掉了，而且重启十几分钟后又会挂掉，瞬间公司就炸锅了，网管、开发人员、技术主管集体冒汗，在紧急处理过程中，还不断有院方电话打给主管、总经理直到大老板，领导就站在我们背后着急的等待我们处理，我想很多人应该有画面了。

##### 2）、原因

  大概到中午都没解决，因为没有日志平台的情况下，定位问题是一件不容易的事情，后来在中午休息时间技术主管和我们终于发现了门诊服务中调用某软his接口出现超时，而周一上午的流量又很大，平常偶尔超时也没问题没人在意，这次一个小小的接口超时竟然直接把服务全部堵塞，调用该接口的挂号和门诊服务全部挂掉，而和门诊服务有一点耦合的检查报告服务也在疯狂的超时等待又超时又等待中挂掉了。

  最终，紧急联系院方找厂商服务团队查找该接口问题，同时我们临时把几个服务全部重启，总算在所有人惶惶不安的努力下3点之前恢复了正常。

##### 3）、总结及处理

  事后，老板大发雷霆，并召开批斗大会点出了团队没有危机处理预案等等种种问题，据说是被院方碉堡了。我们怀着谦虚忐忑的心情在小本上疯狂做笔记(做样子)，算是挺过去了，唯独主管比较难受，要亲自写好几个事故报告给甲方，懂的都懂。

  接口超时时间之后发现设置为60秒，真特么离谱啊，之前竟没一个人关注(包括我)，没问题的情况下自然万事大吉，但凡出了问题，60秒的超时时间这是人干的事么，有什么接口若需要60秒，那本身就是一枚定时炸弹，必须一开始就拆掉。

  很多公司的项目其实都存在这个问题，碍于调用第三方接口难以预估超时时间，所以就设置的比较长，可实际上，这会给项目带来莫大的隐患，处理方式很简单：

>   i）、一定要和对接的厂商确定接口的大概超时时间，有个基本的范围，因为你很难要求其他公司给你做好接口的完善，很多是不会搭理你的，你也看不见人家接口怎么写的，那么就要知道个大概，然后自己这边才好设置；
> 
>   ii）、在预估项目上线后流量会成倍增长的情况下，一定要对项目主要接口做压测，这是公司的测试团队必须要做的事情，我们公司这次就是测试人员不会压测，也没人重视，所以功能没问题就上线了，事后所有测试人员都被要求参加压测培训；
> 
>   iii）、只要是微服务，请一定**引入熔断机制** ，这次事故过后，团队深刻反思，明明用了SpringCloud，但调用第三方接口的位置都没有做熔断处理，如果一开始做了，那么这次事故至少我们可以抽身，服务熔断降级后，既不会出现雪崩影响到其他服务，主要责任也在某软，给自己公司更多弹性处理的空间，而不是现在反而担负了主要责任。

## 2、锁表事故

##### 1）、现象

  这个事故和前面的相比算是小事故了，但依然令人心惊胆战，毕竟快过年了，谁也不想出问题。墨菲定律讲过，越是你害怕的事情越是会到来，果不其然，年前大概就是前一两周的样子，某天下午一家三甲医院的挂号服务未响应，在前端的效果就是，你打开了小程序，点击了挂号服务，然后某个功能一直加载中，最后页面未响应或假死。

##### 2）、原因

  锁表，因为负责维护该医院的同事，在下午四点中的时候给挂号表新增了一个可以为空的字段，而挂号表是百万数据的大表，直接执行SQL新增字段还附带部分条件，直接导致整个表都锁掉了，前端发来的请求就一直无法对该表执行其他操作，最终未响应及假死。

  既然锁了就要解，操作很简单，但集成同事刚好一时联系不上，开发人员又不熟悉内网环境，前后花了一个小时时间才解锁恢复正常，在一堆病患使用过程中，一个小时时间内都无法挂号，这背后的凶残你可想而知。

##### 3）、总结及处理

  给该表迅速解锁，有条件的话最好让本公司专业DBA或集成同事来操作，他们更熟悉数据库服务及项目部署，操作更安全，如果公司没有这样的同事，只能百度一下咯。

MySQL解锁方式：

```sql
# 1. 查看当前数据库锁表的情况 
SELECT * FROM information_schema.INNODB_TRX; 
# 2. 杀掉查询结果中锁表的trx_mysql_thread_id 
kill trx_mysql_thread_id
```

Oracle解锁方式：

```sql
# 查看被锁的表ct
select b.owner, b.object_name, a.session_id, a.locked_mode
from v$locked_object a, dba_objects b where b.OBJECT_ID = a.OBJECT_ID

# 查看连接的进程
select sid, serial#, username, osuser from v$session;

# 杀掉进程 sid, serial#
alter system kill session '678,983';
```

> 切记，给大表新增字段以及其他操作，一定要选择流量最小的时间段，比如凌晨以后，这样可以避免造成生产环境事故。

### 总结

> 1）、首先，接口超时时间的设置不是小问题，希望大家引以为戒，一是要充分和对接厂商沟通，对接口情况有底，一个接口的响应时间理论上是毫秒级的，大厂甚至对接口超时时间都有明确规范，小厂因为身不由己，只能曲线救国，设置一个合理的范围；
> 
>    其次，一定要在测试阶段进行核心接口的压测，某种程度上可以提前暴露问题；
> 
>    最后，微服务一定要引入熔断机制，并且重视使用；
> 
> 2）、大表操作要谨慎，要么选择合适的工具来实时操作大表(可以百度非常多)，要么就选择流量最少的时间去操作，无非也就是凌晨，因为没啥人用，而且执行SQL操作大表时最好不要附带条件比如设置默认值之类的，这样会明显提升速度，把复杂的语句分段执行效果更佳，大家可以试试。

## 个人总结 24.5.6
