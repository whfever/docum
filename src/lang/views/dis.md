#分布式

##iD
###ID
UUID的优点就是他的性能比较高，不依赖网络，本地就可以生成，使用起来也比较简单。
但是他也有两个比较明显的缺点，那就是*长度过长和没有任何含义*
 11
### SnowFlake
所以，基于时间戳+数据中心标识+机器标识+序列号，就保证了在不同进程中主键的不重复，在相同进程中主键的有序性。

雪花算法之所以被广泛使用，主要是因为他有以下优点：
1
高性能高可用：生成时不依赖于数据库，完全在内存中生成
2
高吞吐：每秒钟能生成数百万的自增 ID
3
ID 自增：在单个进程中，生成的ID是自增的，可以用作数据库主键做范围查询。但是需要注意的是，在集群中是没办法保证一定顺序递增的。

SnowFlake 算法的缺点或者限制：

1、在Snowflake算法中，每个节点的机器ID和数据中心ID都是硬编码在代码中的，而且这些ID是全局唯一的。当某个节点出现故障或者需要扩容时，就需要更改其对应的机器ID或数据中心ID，但是这个过程比较麻烦，需要重新编译代码，重新部署系统。还有就是，如果某个节点的机器ID或数据中心ID被设置成了已经被分配的ID，那么就会出现重复的ID，这样会导致系统的错误和异常。

2、Snowflake算法中，需要使用zookeeper来协调各个节点的ID生成，但是ZK的部署其实是有挺大的成本的，并且zookeeper本身也可能成为系统的瓶颈。

3、依赖于系统时间的一致性，如果系统*时间被回拨*，或者不一致，可能会造成 ID 重复。


## 事务
首先，二者的实现机制不同，2PC使用*协调者和参与者*的方式来实现分布式事务，而TCC采用分阶段提交的方式。


处理方式不同，2PC采用预写式日志的方式，在提交和回滚阶段需要协调者和参与者之间进行多次网络通信，整个事务处理过程较为复杂。TCC则不需要网络通信，只需要在Try、Confirm和Cancel阶段执行相应的业务逻辑。

异常处理不同，2PC需要处理网络、节点故障等异常情况，可能会导致整个事务无法提交或回滚，处理异常情况的复杂度较高。而TCC只需要处理业务异常情况，异常处理相对简单。

适用场景不同，2PC适用于对事务一致性要求较高的场景，例如银行转账等，需要保证数据一致性和完整性。而TCC适用于对事务一致性要求不那么高的场景，例如电商库存扣减等，需要保证数据最终一致性即可。

最初TCC的设计是强一致性，基本上一次事务执行完之后，数据是一致的，要么都commit，要么都cancel。

但是其实在实际使用过程中，可能会采用最终一致性的思想，比如commit失败之后，进行异步重试让他尝试成功，而不是立刻cancel