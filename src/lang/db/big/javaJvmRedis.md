## JVM

> 下面是一些学习JVM的建议：
>
> 1. 了解JVM的体系结构和工作原理。JVM由类加载器、运行时数据区和执行引擎组成。了解各个部分的作用和关系可以帮助你更好地理解JVM的工作原理。
> 2. 学习JVM的调优。JVM调优可以提高程序的性能和稳定性。了解如何设置JVM参数、如何利用GC日志进行分析等技巧可以帮助你优化程序。
> 3. 深入了解JVM的垃圾收集器。垃圾收集是JVM的一个重要功能，了解不同的垃圾收集算法、各种垃圾收集器的特点和使用场景可以帮助你更好地进行垃圾收集的调优。
> 4. 学习JVM与并发编程的关系。JVM对并发编程提供了强大的支持，线程、锁、原子操作等都是JVM提供的工具。了解JVM对并发编程的支持可以帮助你更好地编写高效的多线程程序。
> 5. 掌握JVM调试技巧。当程序出现问题时，调试是解决问题的关键。学会如何使用JVM自带的工具进行调试，如jmap、jstack、jconsole等可以帮助你更快地定位和解决问题。

### JVM的体系结构和工作原理

JVM（Java Virtual Machine）是一种虚拟机，它是Java语言的核心和基础，负责将编写的Java代码转换成可执行的字节码，并在运行时提供内存管理、垃圾收集、安全性等各种支持。

JVM的体系结构包括三个主要组成部分：类加载器、运行时数据区和执行引擎。它们之间的关系如下：

![JVM architecture](https://i.imgur.com/YH0UnlO.png)

1. 类加载器：Java程序在运行时，需要动态地加载类文件到内存中进行解析和执行。类加载器就是用来完成这个任务的。类加载器可以根据不同的策略（如父亲委托机制、双亲委派机制、扩展类加载器等）查找并加载类文件，最终形成Java对象。
2. 运行时数据区：运行时数据区是JVM用来管理内存的地方，如图所示包括了堆区、方法区、虚拟机栈、本地方法栈以及程序计数器。其中，堆区和方法区是JVM内存管理的核心，负责存储Java对象和类信息；虚拟机栈和本地方法栈分别为Java方法调用提供了内存空间；程序计数器则记录当前线程所执行的字节码指令地址。
3. 执行引擎：执行引擎是JVM的核心之一，它负责将字节码解释或编译为机器码，并执行程序。执行引擎包括两个主要部分：解释器和即时编译器（JIT）。

JVM内存可以分成以下几个区：

1. 堆区：堆区是Java对象最常驻的内存区域，用来存储动态生成的Java对象。Java程序员不需要手动管理堆上的内存，JVM会自动进行垃圾回收。堆区又被细分为新生代和老年代，其中新生代又分为Eden区、Survivor区1和Survivor区2。
2. 方法区：方法区用于存储JVM加载的类信息、常量、静态变量等数据。在方法区中有一个特殊的永久代（Permanant Generation），也称作元空间（Metaspace），用于存储类的元数据信息。
3. 虚拟机栈：虚拟机栈用来存储Java方法执行的线程栈帧，每个线程在执行Java方法时，都会创建对应的线程栈帧，用于存储局部变量表、操作数栈、方法返回值等信息。
4. 本地方法栈：本地方法栈用来存储Java程序调用原生方法（Native Method）的状态信息。
5. 程序计数器：程序计数器用来记录当前线程所执行的字节码指令地址，JVM通过程序计数器来控制线程执行。

以上就是JVM的体系结构、工作原理以及内存结构的简单介绍。

#### 类加载器执行过程？策略有哪些

类加载器是JVM的组成部分之一，用于将编译好的Java类文件加载到内存中。在应用程序运行期间，可能需要动态地加载、卸载和重新加载类，而类加载器就是用于完成这个任务的。

Java虚拟机规范将类加载过程划分为三个步骤：

1. 加载（Loading）：查找并加载类的二进制数据。
2. 链接（Linking）：将类的二进制数据合并到JVM的运行时状态中，并进行校验、准备和解析等操作。
3. 初始化（Initialization）：对类进行初始化，包括执行静态变量的赋值和静态代码块的执行等操作。

类加载器的执行过程可以分为以下几个步骤：

1. 搜索类：当一个类被使用时，JVM会首先使用当前线程的类加载器去搜索该类。
2. 定义类：如果类没有被加载，JVM会通过类加载器读取类的二进制数据，并生成对应的Class对象。
3. 解析类：在链接阶段，JVM会对类的二进制数据进行校验、准备和解析等操作。其中解析阶段包括将常量池中的符号引用转换为直接引用等操作。
4. 初始化类：在初始化阶段，JVM会对类进行初始化，包括执行静态变量的赋值和静态代码块的执行等操作。如果一个类还没有被初始化，JVM会先初始化该类的父类。

Java虚拟机规范定义了三种类加载器：

1. 启动类加载器（Bootstrap ClassLoader）：启动类加载器是JVM内置的类加载器，用于加载Java平台核心库中的类，如java.lang.*、java.util.*等。
2. 扩展类加载器（Extension ClassLoader）：扩展类加载器用于加载Java平台扩展库中的类，位于JRE/lib/ext目录下。
3. 应用程序类加载器（Application ClassLoader）：应用程序类加载器也称为系统类加载器，用于加载应用程序classpath目录下的类。

除此之外，Java虚拟机还支持自定义类加载器。自定义类加载器可以继承ClassLoader并重写findClass()方法来实现特定的类加载策略。

Java虚拟机采用了委派机制来实现类加载器的层次结构。当一个类加载器需要加载一个类时，它会先将任务委派给父类加载器去完成，父类加载器再将任务委派给它的父类加载器，直到达到启动类加载器。如果所有的父类加载器都无法加载这个类，那么当前类加载器会尝试自己去加载这个类。

这种委派机制确保了Java类的唯一性和安全性。

```
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    //              -----??-----
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // 首先，检查是否已经被类加载器加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    // 存在父加载器，递归的交由父加载器
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        // 直到最上面的Bootstrap类加载器
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
 
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
```





#### 深入了解JVM的垃圾收集器

JVM垃圾回收是指JVM自动管理内存，清除不再使用的对象并释放这些对象占用的内存空间。Java语言使用的是自动内存管理机制，也就是说程序员不需要手动管理内存，JVM会自动进行垃圾回收。

垃圾收集的方法有以下几种：

1. 标记-清除算法（Mark and Sweep）：该算法将内存分为已使用和未使用两部分，先标记出所有已使用的对象，然后清除掉所有未被标记的对象。该算法的缺点是会产生大量的内存碎片。
2. 复制算法（Copy）：该算法将内存分为两个区域，每次使用其中一个区域，当垃圾回收时，将正在使用的对象复制到另一个区域中，清除原来正在使用的区域。该算法的优点是简单高效，但是需要两倍的内存空间。
3. 标记-整理算法（Mark and Compact）：该算法与标记-清除算法类似，但是它在清除之后还会将所有存活的对象往一端移动，整理出连续的空闲内存空间，以便未来的对象分配。该算法的缺点是移动对象需要花费较多的时间。
4. 分代算法（Generational）：该算法将内存分为几个年轻代和一个老年代，大部分对象在创建之后会先被分配到年轻代中，年轻代采用复制算法进行垃圾回收，老年代采用标记-整理算法进行垃圾回收。该算法能够有效地提高垃圾回收效率。

JVM执行垃圾回收时，需要判断哪些对象是存活的，哪些是垃圾对象。通常使用可达性分析算法来判定对象是否可以被回收。这种算法假设一个对象为可达对象当且仅当：

1. 该对象被某个变量引用；
2. 该对象被其他可达对象引用。

如果一个对象不满足上述条件，则认为它是垃圾对象，可以被回收。



#### Java 内存分配与回收策略

Java内存分配与回收策略是JVM进行垃圾回收的关键。在Java中，内存分为堆（Heap）和栈（Stack）。栈用于存放基本类型数据和对象的引用，而堆则用于存放对象实例。

堆内存又分为年轻代（Young Generation）、老年代（Old Generation）和永久代（PermGen），其中年轻代又包括Eden区、Survivor区1和Survivor区2。JVM采用分代垃圾收集算法，根据不同的对象生命周期将内存划分为不同的代，以便更好地管理内存。

Minor GC和Major GC（Full GC）是JVM进行垃圾回收的两种方式。Minor GC通常发生在年轻代，用于清理年轻代中的垃圾对象。在Minor GC时，虚拟机会按照对象年龄从新生代中的Eden区和Survivor区1移动到Survivor区2，当某个对象经过多次Minor GC后仍然存活，就会被移到老年代中。因此，Minor GC可以看做是一个对象筛选的过程，只有部分对象能够进入老年代。

Major GC也称为Full GC，是对整个堆空间进行垃圾回收。在Major GC时，虚拟机会清理整个堆空间中的垃圾对象，包括年轻代和老年代。因为Major GC需要扫描整个堆空间，所以它的时间比较长，会造成较长的停顿时间。一般情况下，我们希望尽可能地减少Major GC的次数和时间。

Java内存分配与回收策略可以归纳为以下几个方面：

1. 对象优先在Eden区中分配：大部分新生对象都会被分配到Eden区，只有部分特殊的对象才会直接分配到老年代中。
2. 大对象直接进入老年代：如果一个对象很大，就不应该被分配到年轻代中，而是应该直接进入老年代。
3. 长期存活的对象将进入老年代：经过多次Minor GC后仍然存活的对象会被移到老年代中，以便更好地管理内存。
4. 动态对象年龄判定：JVM会根据动态对象年龄判定策略来决定哪些对象进入老年代。如果一组对象年龄超过了Survivor区域可容纳的大小，那么这些对象直接进入老年代。
5. 空间分配担保：在进行Minor GC时，如果Survivor区无法容纳所有存活的对象，那么原本分配到年轻代中的对象就会直接进入老年代。这一过程称为空间分配担保，以确保垃圾回收器能够顺利工作。





## JUC

JUC（Java.util.concurrent）是Java的并发工具包，包含了一些常用的工具类和线程池等实现。以下是JUC的知识点：

一、原子类

1. AtomicInteger、AtomicLong：提供了原子操作的功能，避免了多线程环境下的竞争条件问题。
2. AtomicBoolean：提供了原子操作的功能，可以用于进行布尔类型的原子操作。
3. AtomicReference：提供了对引用类型的原子操作，可以保证在多线程环境下引用的对应关系不会发生变化。
4. AtomicStampedReference：提供了对带有版本号的引用类型的原子操作，可以避免ABA问题。
5. AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater：通过反射机制实现对对象字段的原子更新操作。

二、锁

1. synchronized：Java中最常用的锁机制，通过对对象或方法加锁来保证线程安全。
2. ReentrantLock：可重入锁，与synchronized相似，但提供了更丰富的功能，如公平锁和非公平锁、可中断锁和超时锁等。
3. ReadWriteLock：读写锁，允许同一时间多个线程同时读取，但只允许一个线程写入。
4. StampedLock：乐观读写锁，相比ReadWriteLock，提供了更高的并发性能。
5. Condition：在锁的基础上提供了精细的等待和通知机制，可用于实现线程间协作。

三、并发容器

1. ConcurrentHashMap：线程安全的HashMap实现，通过分段锁提高并发性能。
2. CopyOnWriteArrayList、CopyOnWriteArraySet：读写分离的List和Set实现。
3. ConcurrentLinkedQueue、ConcurrentLinkedDeque：无阻塞队列和双端队列实现。
4. BlockingQueue：阻塞队列接口，定义了一系列阻塞操作，如put、take等。

四、线程池

1. ThreadPoolExecutor：Java中最常用的线程池实现，通过控制线程数量、任务队列长度和工作线程的创建和销毁来优化并发性能。
2. ScheduledThreadPoolExecutor：定时任务线程池，可以周期性地执行指定的任务。
3. ForkJoinPool：Java 7引入的线程池实现，主要用于执行大量递归计算任务。

五、原子操作类

1. CountDownLatch：倒计数门闩，可以用于控制线程的执行顺序。
2. CyclicBarrier：循环屏障，可以让多个线程相互等待，直到所有线程达到一个执行点后再继续执行。
3. Semaphore：信号量，可以用于控制同时运行的线程数量。

以上是JUC的主要知识点。学习JUC需要了解并发编程的基础知识，如线程、锁和同步等概念。同时，需要对Java语言的多线程相关API有一定的掌握程度。

### Synchronized 与 Lock

1）Synchronized 能实现的功能 Lock 都可以实现，而且 Lock 比 Synchronized 更好用，更灵 活。

 2）Synchronized 可以自动上锁和解锁；Lock 需要手动上锁和解锁 

- Synchronized 线程1(获得锁->阻塞)、线程2(等待)；lock就不一定会一直等待下去，lock会有一个**trylock**去尝试获取锁，不会造成长久的等待。

- Synchronized **是可重入锁**，不可以中断的，**非公平的**；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁；
- Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码；

###  Runnable 和 Callable 的区别

 1）Runnable 接口中的方法没有返回值；Callable 接口中的方法有返回值 2）Runnable 接口中的方法没有抛出异常；Callable 接口中的方法抛出了异常 3）Runnable 接口中的落地方法是 call 方法；Callable 接口中的落地方法是 run 方法





## Redis

### 缓存穿透、缓存雪崩、缓存击穿

 1）缓存穿透是指查询一个一定不存在的数据。由于缓存命不中时会去查询数据库，查不到 数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿 透。 

解决方案： 1 是将空对象也缓存起来，并给它设置一个很短的过期时间，最长不超过 5 分钟 ② 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定 不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

 2）如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上， 就会造成缓存雪崩。 解决方案： 尽量让失效的时间点不分布在同一个时间点 

3）缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，当这个 key 在失效的瞬间， 持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。 解决方案： 可以设置 key 永不过期

### 持久化 

1）RDB 持久化： 1 在指定的时间间隔内持久化 2 服务 shutdown 会自动持久化 ③ 输入 bgsave 也会持久化 

2）AOF : 以日志形式记录每个更新操作 Redis 重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。 保存策略： 推荐（并且也是默认）的措施为每秒持久化一次，这种策略可以兼顾速度和安全性。

 缺点： 1 比起 RDB 占用更多的磁盘空间 2 恢复备份速度要慢 3 每次读写都同步的话，有一定的性能压力 4 存在个别 Bug，造成恢复不能 选择策略： 官方推荐： string 字符串 list 可以重复的集合 set 不可以重复的集合 hash 类似于 Map zset(sorted set） 带分数的 set 尚硅谷大数据技术之高频面试题 ————————————————————————————— 211 如果对数据不敏感，可以选单独用 RDB；不建议单独用 AOF，因为可能出现 Bug;如果 只是做纯内存缓存，可以都不用

### 乐观锁 

执行操作前假设当前操作不会被打断（乐观）。基于这个假设，我们在做操作前不会锁 定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。Redis 使用的就是乐观锁。

### redis 是单线程的，为什么那么快

1)完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。 

2)数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的 

3)采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的 切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死 锁而导致的性能消耗 

4)使用多路 I/O 复用模型，非阻塞 IO 
5)使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样， Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去 移动和请

## MySql

### MyISAM 与 InnoDB 的区别 

| 对比项 | MyISAM                                              | InnoDB                                                       |
| ------ | --------------------------------------------------- | ------------------------------------------------------------ |
| 外键   | 不支持                                              | 支持                                                         |
| 事务   | 不支持                                              | 支持                                                         |
| 行表锁 | 表锁即使操作一条记录也会 锁住整个表，不适合高并发的 | 操作 行锁,操作时只锁某一行，不对 其它行有影响， 适合高并发的操作 |
| 缓存   | 只缓存索引，不缓存真实数据                          | 不仅缓存索引还要缓存真实数 据，对内存要求较高，而且内 存大小对性能有决定性的影响 |

### MySQL 的事务

#### 一、事务的基本要素（ACID）

 1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停 滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发 生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本 单位 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。 尚硅谷大数据技术之高频面试题 ————————————————————————————— 213 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此 没有任何干扰。比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前，B 不能向这张卡 转账。 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能 回滚。 二、事务的并发问

#### 二、事务的并发问题

 1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数 据 2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据 作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致 3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统 管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条 记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

####  三、MySQL 事务隔离级别

 事务隔离级别 脏读 不可重复读 幻读 

读未提交（read-uncommitted） 是 是 是

 不可重复读（read-committed） 否 是 是 

可重复读（repeatable-read） 否 否 是 

串行化（serializable） 否 否 