# code

## java

## 设计模式


23种设计模式：

1. 创建型模式（5）：
- 工厂方法模式、抽象工厂模式、
>抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。
- 生成器设计模式 生成器方法通常支持方法链
- 单例模式:懒汉式、饿汉式
    1. *双重检查锁*线程安全,volatile关键字严格遵循happens-before原则
    2. 静态内部类 延迟初始化，而且由 JVM 提供了对线程安全的支持、
    3. 枚举 :枚举类型是线程安全的，并且只会装载一次  *反射安全，序列化安全*
> Java的**序列化机制**针对枚举类型是特殊处理的。简单来讲，在序列化枚举类型时，只会存储枚举类的引用和枚举常量的名称。随后的反序列化的过程中，这些信息被用来在运行时环境中查找存在的枚举类型对象。
> 在 Java 中，对象的序列化可以通过实现两种接口来实现，如果实现的是 Serializable 接口，则所有的序列化将会自动进行，如果实现的是 Externalizable 接口，则需要在 writeExternal 方法中指定要序列化的字段，与 *transient* 关键字修饰无关。

- 建造者模式、原型模式
1. 结构型模式（7）：
适配器模式、
桥接模式：业务逻辑或一个大类拆分为不同的层次结构， 从而能独立地进行开发
组合模式、装饰模式、
外观模式 : 外观模式简化了客户端与复杂视频转换框架之间的*交互*。
    你可以让自己的代码独立于复杂子系统。
    外观可能成为与程序中所有类都耦合的上帝对象。

> 外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整子系统上。
享元模式、代理模式
2. 行为型模式(12)：
   命令模式、
 中介者模式
> 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。
解释器模式、迭代器模式、观察者模式、状态模式、
#### 策略模式
桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

命令模式和策略看上去很像， 因为两者都能通过某些行为来**参数化对象**。 但是， 它们的意图有非常大的不同。

你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。

另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。

装饰模式可让你更改对象的外表， 策略则让你能够改变其本质。

模板方法模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。

状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。
模板方法模式、访问者模式，

### 七大原则：
单一职责原则，接口隔离原则 合成复用原则，迪米特法则（委托类）    *解耦*

里氏**代换**原则，依赖倒置原则， 开闭原则，     *扩展*

![Alt text](D:/../../../../docs/book/images/code/pattern.png)